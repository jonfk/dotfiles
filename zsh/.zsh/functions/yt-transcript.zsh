# Download YouTube transcripts with official subs first, then auto-generated fallback.
# Generates a .md file (no timestamps) from VTT subtitles.
yt-transcript() {
	local url="$1"
	local lang="${2:-en}"
	local format="${3:-vtt}"
	local tmpdir
	local -a base_args
	local rc

	if [[ -z "$url" ]]; then
		echo "Usage: yt-transcript <youtube-url> [lang]" >&2
		echo "Example: yt-transcript 'https://www.youtube.com/watch?v=...' en" >&2
		echo "Note: Only VTT subtitles are supported right now." >&2
		return 1
	fi

	if ! command -v yt-dlp >/dev/null 2>&1; then
		echo "yt-dlp not found in PATH." >&2
		return 127
	fi

	format="${format:l}"
	if [[ "$format" != "vtt" ]]; then
		echo "Unsupported subtitle format '$format'. Only vtt is supported right now; please add support for it." >&2
		return 2
	fi

	tmpdir=$(mktemp -d 2>/dev/null)
	if [[ -z "$tmpdir" ]]; then
		echo "Failed to create temporary directory." >&2
		return 1
	fi

	base_args=(--skip-download --sub-langs "$lang" --sub-format "$format" --paths "$tmpdir")

	if ! yt-dlp "${base_args[@]}" --write-subs "$url"; then
		echo "yt-dlp failed while fetching official subtitles." >&2
		rm -rf "$tmpdir"
		return 1
	fi

	_yt_transcript_process_files "$tmpdir"
	rc=$?
	if (( rc == 0 )); then
		rm -rf "$tmpdir"
		return 0
	elif (( rc == 2 || rc == 3 )); then
		rm -rf "$tmpdir"
		return "$rc"
	fi

	if ! yt-dlp "${base_args[@]}" --write-auto-subs "$url"; then
		echo "yt-dlp failed while fetching autogenerated subtitles." >&2
		rm -rf "$tmpdir"
		return 1
	fi

	_yt_transcript_process_files "$tmpdir"
	rc=$?
	if (( rc == 0 )); then
		rm -rf "$tmpdir"
		return 0
	elif (( rc == 2 || rc == 3 )); then
		rm -rf "$tmpdir"
		return "$rc"
	fi

	rm -rf "$tmpdir"
	echo "No subtitles found for language '$lang'." >&2
	return 1
}

_yt_transcript_process_files() {
	local tmpdir="$1"
	local file
	local found=0
	local -a files
	local ext
	local dest

	while IFS= read -r -d '' file; do
		found=1
		files+=("$file")
	done < <(find "$tmpdir" -type f -print0)

	if (( ! found )); then
		return 1
	fi

	for file in "${files[@]}"; do
		ext="${file##*.}"
		ext="${ext:l}"
		if [[ "$ext" != "vtt" ]]; then
			echo "Unsupported subtitle format detected: .$ext. Please add support for it." >&2
			return 2
		fi
	done

	for file in "${files[@]}"; do
		dest="./${file##*/}"
		command mv "$file" "$dest"
		if ! _yt_transcript_vtt_to_md "$dest"; then
			return 3
		fi
	done

	return 0
}

_yt_transcript_vtt_to_md() {
	local vtt="$1"
	local ext="${vtt##*.}"
	local md

	ext="${ext:l}"
	if [[ "$ext" != "vtt" ]]; then
		echo "Unsupported subtitle format for conversion: .$ext. Please add support for it." >&2
		return 2
	fi

	md="${vtt%.*}.md"

	awk '
	BEGIN { in_note=0; in_block=0; in_header=0; prev_blank=0 }
	NR==1 { sub(/^\xEF\xBB\xBF/, "", $0) }
	/^WEBVTT/ { in_header=1; next }
	in_header {
		if ($0 == "") { in_header=0 }
		next
	}
	/^NOTE($| )/ { in_note=1; next }
	in_note {
		if ($0 == "") { in_note=0 }
		next
	}
	/^(STYLE|REGION)$/ { in_block=1; next }
	in_block {
		if ($0 == "") { in_block=0 }
		next
	}
	/-->/ { next }
	{
		# For more complex parsing (nested tags, entities), a Python parser may be more robust.
		gsub(/<[^>]*>/, "", $0)
		gsub(/[ \t]+/, " ", $0)
		sub(/^ /, "", $0)
		sub(/ $/, "", $0)
		if ($0 == "") {
			if (prev_blank == 0) { print ""; prev_blank=1 }
			next
		}
		if ($0 == prev_line) { next }
		prev_line=$0
		prev_blank=0
		print
	}
	' "$vtt" > "$md"
}
